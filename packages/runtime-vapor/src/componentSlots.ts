import { type IfAny, isArray } from '@vue/shared'
import { baseWatch } from '@vue/reactivity'
import type { ComponentInternalInstance } from './component'
import type { Block } from './apiRender'

// TODO: SSR

export type Slot<T extends any = any> = (
  ...args: IfAny<T, any[], [T] | (T extends undefined ? [] : never)>
) => Block

export type InternalSlots = {
  [name: string]: Slot | undefined
}

export type Slots = Readonly<InternalSlots>

export interface DynamicSlot {
  name: string
  fn: Slot
  key?: string
}

export type DinamicSlotsGetter = () => (DynamicSlot | DynamicSlot[])[]

export const initSlots = (
  instance: ComponentInternalInstance,
  slots: InternalSlots | null,
  dynamicSlotsGetter: DinamicSlotsGetter | null = null,
) => {
  if (!slots) slots = {}
  instance.slots = createSlots(slots, dynamicSlotsGetter)
}

const createSlots = (
  slots: InternalSlots,
  dynamicSlotsGetter: DinamicSlotsGetter | null = null,
): InternalSlots => {
  const dynamicSlotKeys: Record<string, true> = {}
  baseWatch(() => {
    const dynamicSlots = dynamicSlotsGetter?.() ?? []
    for (let i = 0; i < dynamicSlots.length; i++) {
      const slot = dynamicSlots[i]
      // array of dynamic slot generated by <template v-for="..." #[...]>
      if (isArray(slot)) {
        for (let j = 0; j < slot.length; j++) {
          slots[slot[j].name] = slot[j].fn
          dynamicSlotKeys[slot[j].name] = true
        }
      } else if (slot) {
        // conditional single slot generated by <template v-if="..." #foo>
        slots[slot.name] = slot.key
          ? (...args: any[]) => {
              const res = slot.fn(...args)
              // attach branch key so each conditional branch is considered a
              // different fragment
              if (res) (res as any).key = slot.key
              return res
            }
          : slot.fn
        dynamicSlotKeys[slot.name] = true
      }
    }
    // delete stale slots
    for (const key in dynamicSlotKeys) {
      if (
        !dynamicSlots.some(slot =>
          isArray(slot) ? slot.some(s => s.name === key) : slot?.name === key,
        )
      ) {
        delete slots[key]
      }
    }
  })
  return slots
}
